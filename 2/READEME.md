# chapter 2

## 2.4 优先队列

优先队列的用例:

- 查找N个元素中最`大`的M个元素

我第一反应是使用最`大`优先队列,使用长度为`M`的最大优先队列保存我们要的元素其他的全丢弃,完美.
但是仔细想一下,最大优先队列只能选出当前队列中M个元素中的最大值,而且这个最大值与`N个元素中最大M个元素`没有必然联系,我们使用优先队列的目的是剔除不符合条件的元素.
所以正确方式是使用长度为`M`的最小优先队列,在把原始数据插入到队列的过程中,队列中保持目前最大的`M`个值,每插入一个值就把堆顶上的值剔除掉.

- 由此可知,如果我们要查找N个元素中最小的M个元素,我们要使用最`大`优先队列.

## 2.4.4.7 索引优先队列用例

note:
多向归并问题:将多个有序的输入流归并成一个有序的输出流,许多应用都会遇到这个问题,输入可能来自与多种科学仪器的输出(按时间排序),或是来自多个音乐或电影网站的信息列表(按名称或艺术家名字排序).
我们在归并排序中遇到过双向归并问题:将两个有序的子数组归并成一个有序的数组,也是多向归并的一种.
多向归并我们可以总结出以下特征:

1. 每个子队列都是有序的,队首是最大值或者最小值
2. 在归并的时候需要每个队列都取出队首的值进行比较,N个队列就会有N个值进行比较
3. 在N个元素中找到最大值以后需要将其放入总队列中,然后从最大值所属队列中再取出一个值进行比较

这就是我们为什么使用索引优先队列而非优先队列的原因:我们需要知道这个最大(小)值属于哪个队列,然后从该队列再出队一个值再次进行比较

如何在优先队列的基础上实现索引优先队列呢?
1. 加一个 int[N] index的索引数组,index[k]就是绑定元素在堆数组的下标位置

## 